import logging
import sys
import os
import time
import json
from typing import Dict, List, Optional
from pathlib import Path
import requests
from requests.auth import HTTPBasicAuth
from mcp.server.fastmcp import FastMCP

name = "linshare-mcp-server"

# Configure logging to stderr (important for MCP)
logging.basicConfig(
    level=logging.INFO,
    format="%(name)s - %(levelname)s - %(message)s",
    handlers=[logging.StreamHandler(sys.stderr)]
)
logger = logging.getLogger(name)

# Create FastMCP instance
mcp = FastMCP(name=name)

# LinShare configuration from environment variables
LINSHARE_BASE_URL = os.getenv("LINSHARE_BASE_URL")
LINSHARE_USERNAME = os.getenv("LINSHARE_USERNAME")
LINSHARE_PASSWORD = os.getenv("LINSHARE_PASSWORD")
# Directory configurations with sensible defaults
LINSHARE_UPLOAD_DIR = Path(os.getenv('LINSHARE_UPLOAD_DIR', Path.home() / 'LinShareUploads'))
LINSHARE_DOWNLOAD_DIR = Path(os.getenv('LINSHARE_DOWNLOAD_DIR', Path.home() / 'LinShareDownloads'))

# Create directories if they don't exist
LINSHARE_UPLOAD_DIR.mkdir(parents=True, exist_ok=True)
LINSHARE_DOWNLOAD_DIR.mkdir(parents=True, exist_ok=True)

# Common role UUIDs (from LinShare database)
COMMON_ROLES = {
    'WORK_SPACE': {
        'WORK_SPACE_ADMIN': '9e73e962-c233-4b4a-be1c-e8d9547acbdf',
        'WORK_SPACE_WRITER': '963025ca-8220-4915-b4fc-dba7b0b56100',
        'WORK_SPACE_READER': '556404b5-09b0-413e-a025-79ee40e043e4'
    }
}




# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

def get_role_uuid(role_name: str) -> Optional[str]:
    """Get role UUID by name from COMMON_ROLES."""
    role_name_upper = role_name.upper().strip()

    # Look inside WORK_SPACE
    if 'WORK_SPACE' in COMMON_ROLES and role_name_upper in COMMON_ROLES['WORK_SPACE']:
        return COMMON_ROLES['WORK_SPACE'][role_name_upper]

    return None

@mcp.tool()
def show_exact_role_keys() -> str:
    """Show the exact keys in COMMON_ROLES."""
    result = "Exact COMMON_ROLES structure:\n\n"

    result += f"Top-level keys: {list(COMMON_ROLES.keys())}\n\n"

    for top_key in COMMON_ROLES.keys():
        result += f"Under '{top_key}':\n"
        if isinstance(COMMON_ROLES[top_key], dict):
            for sub_key in COMMON_ROLES[top_key].keys():
                result += f"  - '{sub_key}' (repr: {repr(sub_key)})\n"
                result += f"    Value: {COMMON_ROLES[top_key][sub_key]}\n"
        else:
            result += f"  Value: {COMMON_ROLES[top_key]}\n"
        result += "\n"

    return result



# Resources
@mcp.resource("file://upload/{filename}")
def get_upload_file(filename: str) -> str:
    """Read a file from the upload directory."""
    file_path = LINSHARE_UPLOAD_DIR / filename
    
    # Security check
    if not file_path.resolve().is_relative_to(LINSHARE_UPLOAD_DIR.resolve()):
        raise ValueError("Access denied: path outside upload directory")
    
    if not file_path.exists():
        raise FileNotFoundError(f"File not found: {filename}")
    
    with open(file_path, 'rb') as f:
        content = f.read()
    
    return base64.b64encode(content).decode('utf-8')


# Tools
@mcp.tool()
def list_upload_files() -> str:
    """List all files in the upload directory available for uploading.
    
    Returns:
        Formatted list of files ready to upload
    """
    logger.info("Tool called: list_upload_files()")
    
    files = [f for f in LINSHARE_UPLOAD_DIR.glob("*") if f.is_file()]
    
    if not files:
        return f"No files found in upload directory: {LINSHARE_UPLOAD_DIR}\n\nPlace files there to upload them."
    
    result = f"ðŸ“ Files in Upload Directory ({len(files)} files):\n"
    result += f"Location: {LINSHARE_UPLOAD_DIR}\n\n"
    
    for i, file_path in enumerate(files, 1):
        result += f"{i}. {file_path.name}\n"
        result += f"   Size: {format_file_size(file_path.stat().st_size)}\n"
        result += f"   Type: {guess_mime_type(file_path.name)}\n\n"
    
    return result


@mcp.tool()
def upload_file_to_workgroup(
    actor_uuid: str,
    workgroup_uuid: str,
    filename: str,
    folder_uuid: str | None = None,
    description: str | None = None,
    async_upload: bool = False,
    strict: bool = False
) -> str:
    """Upload a file from the upload directory to a LinShare workgroup.
    
    Args:
        actor_uuid: UUID of the user
        workgroup_uuid: UUID of the workgroup
        filename: Name of file in upload directory
        folder_uuid: Optional folder UUID (for uploading to subfolders)
        description: Optional description
        async_upload: Upload asynchronously (default: false)
        strict: Raise error if file with same name exists (default: false)
    
    Returns:
        Upload confirmation
    """
    logger.info(f"Tool called: upload_file_to_workgroup({filename})")
    
    if not LINSHARE_BASE_URL:
        return "Error: LINSHARE_BASE_URL not configured."
    if not LINSHARE_USERNAME or not LINSHARE_PASSWORD:
        return "Error: LinShare credentials not configured."
    
    try:
        from requests.auth import HTTPBasicAuth
        import requests
        
        file_path = LINSHARE_UPLOAD_DIR / filename
        
        # Security check
        if not file_path.resolve().is_relative_to(LINSHARE_UPLOAD_DIR.resolve()):
            return "Error: Access denied - path outside upload directory"
        
        if not file_path.exists():
            return f"Error: File '{filename}' not found in upload directory: {LINSHARE_UPLOAD_DIR}"
        
        # Get file size
        file_size = file_path.stat().st_size
        
        # Build URL
        if folder_uuid:
            url = f"{LINSHARE_BASE_URL}/{actor_uuid}/workgroups/{workgroup_uuid}/folders/{folder_uuid}/entries"
        else:
            url = f"{LINSHARE_BASE_URL}/{actor_uuid}/workgroups/{workgroup_uuid}/entries"
        
        # Query parameters
        params = {
            'async': str(async_upload).lower(),
            'strict': str(strict).lower()
        }
        
        # Prepare multipart form data
        # IMPORTANT: LinShare requires specific field names
        with open(file_path, 'rb') as f:
            files = {
                'file': (filename, f, guess_mime_type(filename))
            }
            
            # Required and optional form fields
            data = {
                'filesize': str(file_size),  # Required!
                'filename': filename,         # Recommended
            }
            
            if description:
                data['description'] = description
            
            # Make the request with Content-Length header
            response = requests.post(
                url,
                params=params,
                files=files,
                data=data,
                auth=HTTPBasicAuth(LINSHARE_USERNAME, LINSHARE_PASSWORD),
                headers={
                    'accept': 'application/json',
                },
                timeout=60
            )
        
        # Check for errors
        if response.status_code != 200:
            error_msg = f"Upload failed with status {response.status_code}\n"
            try:
                error_detail = response.json()
                error_msg += f"Error: {error_detail.get('message', response.text)}"
            except:
                error_msg += f"Response: {response.text}"
            return error_msg
        
        response.raise_for_status()
        result = response.json()
        
        # Format success response
        output = f"âœ… File '{filename}' uploaded successfully to workgroup!\n\n"
        output += f"File: {result.get('name', filename)}\n"
        output += f"UUID: {result.get('uuid', 'N/A')}\n"
        output += f"Size: {format_file_size(result.get('size', file_size))}\n"
        output += f"Type: {result.get('mimeType', 'N/A')}\n"
        output += f"Workgroup: {workgroup_uuid}\n"
        
        if folder_uuid:
            output += f"Folder: {folder_uuid}\n"
        else:
            output += f"Location: Root\n"
        
        if result.get('creationDate'):
            try:
                from datetime import datetime
                dt = datetime.fromisoformat(result['creationDate'].replace('Z', '+00:00'))
                output += f"Uploaded: {dt.strftime('%Y-%m-%d %H:%M:%S')}\n"
            except:
                pass
        
        return output
        
    except requests.exceptions.HTTPError as e:
        logger.error(f"HTTP error uploading file: {e}")
        error_msg = f"Error uploading file: {e.response.status_code}\n"
        try:
            error_detail = e.response.json()
            error_msg += f"Message: {error_detail.get('message', e.response.text)}"
        except:
            error_msg += f"Response: {e.response.text}"
        return error_msg
    except Exception as e:
        logger.error(f"Error uploading file: {e}")
        return f"Error: {str(e)}"

@mcp.tool()
def get_directory_info() -> str:
    """Get information about upload and download directory configuration.
    
    Returns:
        Directory paths and status
    """
    upload_exists = LINSHARE_UPLOAD_DIR.exists()
    download_exists = LINSHARE_DOWNLOAD_DIR.exists()
    
    result = "ðŸ“ LinShare Directory Configuration:\n\n"
    result += f"Upload Directory: {LINSHARE_UPLOAD_DIR}\n"
    result += f"  Status: {'âœ… Exists' if upload_exists else 'âŒ Not found'}\n"
    
    if upload_exists:
        files = [f for f in LINSHARE_UPLOAD_DIR.glob("*") if f.is_file()]
        result += f"  Files ready: {len(files)}\n"
    
    result += f"\nDownload Directory: {LINSHARE_DOWNLOAD_DIR}\n"
    result += f"  Status: {'âœ… Exists' if download_exists else 'âŒ Not found'}\n"
    
    if download_exists:
        files = [f for f in LINSHARE_DOWNLOAD_DIR.glob("*") if f.is_file()]
        result += f"  Downloaded files: {len(files)}\n"
    
    return result


def guess_mime_type(filename: str) -> str:
    """Guess MIME type based on file extension."""
    import mimetypes
    mime_type, _ = mimetypes.guess_type(filename)
    return mime_type or 'application/octet-stream'


def format_file_size(size_bytes: int) -> str:
    """Convert bytes to human-readable format."""
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if size_bytes < 1024.0:
            return f"{size_bytes:.1f} {unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.1f} PB"


@mcp.tool()
def get_user_domain(email: str) -> str:
    """Get the domain UUID for a LinShare user by their email address.
    
    Args:
        email: The user's email address (e.g., abbey.curry@linshare.org)
    
    Returns:
        JSON string with user information including domain UUID
    """
    logger.info(f"Tool called: get_user_domain({email})")
    
    if not LINSHARE_BASE_URL:
        return "Error: LINSHARE_BASE_URL not configured."
    
    if not LINSHARE_USERNAME or not LINSHARE_PASSWORD:
        return "Error: LinShare credentials not configured."
    
    try:
        from urllib.parse import quote
        encoded_email = quote(email, safe='')
        
        url = f"{LINSHARE_BASE_URL}/users/{encoded_email}"
        
        response = requests.get(
            url,
            auth=HTTPBasicAuth(LINSHARE_USERNAME, LINSHARE_PASSWORD),
            headers={'accept': 'application/json'},
            timeout=10
        )
        response.raise_for_status()
        
        user_data = response.json()
        
        result = f"""User Information:
- UUID: {user_data.get('uuid')}
- Domain UUID: {user_data.get('domain')}
- Name: {user_data.get('firstName')} {user_data.get('lastName')}
- Email: {user_data.get('mail')}
- Account Type: {user_data.get('accountType')}
- External: {user_data.get('external')}
"""
        return result
        
    except requests.RequestException as e:
        logger.error(f"Error fetching user data: {str(e)}")
        return f"Error fetching user data: {str(e)}"

@mcp.tool()
def list_shared_space_nodes(user_uuid: str, with_role: bool = False) -> str:
    """List all shared space nodes for a user.
    
    Args:
        user_uuid: The user's UUID (e.g., 7c2d2fdb-9063-46e3-8041-363ae9910d01)
        with_role: Whether to include role information (default: False)
    
    Returns:
        JSON string with list of shared space nodes
    """
    logger.info(f"Tool called: list_shared_space_nodes({user_uuid}, {with_role})")
    
    if not LINSHARE_BASE_URL:
        return "Error: LINSHARE_BASE_URL not configured."
    
    if not LINSHARE_USERNAME or not LINSHARE_PASSWORD:
        return "Error: LinShare credentials not configured."
    
    try:
        url = f"{LINSHARE_BASE_URL}/{user_uuid}/shared_space_nodes"
        params = {'withRole': str(with_role).lower()}
        
        response = requests.get(
            url,
            params=params,
            auth=HTTPBasicAuth(LINSHARE_USERNAME, LINSHARE_PASSWORD),
            headers={'accept': 'application/json'},
            timeout=10
        )
        response.raise_for_status()
        
        nodes = response.json()
        
        if not nodes:
            return "No shared space nodes found for this user."
        
        # Format the response nicely
        result = f"Shared Space Nodes ({len(nodes)} total):\n\n"
        
        for i, node in enumerate(nodes, 1):
            result += f"{i}. {node.get('name', 'Unnamed')}\n"
            result += f"   - UUID: {node.get('uuid')}\n"
            result += f"   - Type: {node.get('nodeType')}\n"
            result += f"   - Creation Date: {node.get('creationDate')}\n"
            result += f"   - Modification Date: {node.get('modificationDate')}\n"
            if with_role and 'role' in node:
                result += f"   - Role: {node.get('role', {}).get('name')}\n"
            result += "\n"
        
        return result
        
    except requests.RequestException as e:
        logger.error(f"Error fetching shared space nodes: {str(e)}")
        return f"Error fetching shared space nodes: {str(e)}"


@mcp.tool()
def list_workgroup_entries(
    actor_uuid: str,
    workgroup_uuid: str
) -> str:
    """List all file and folder entries at the root level of a specific workgroup.
    
    Args:
        actor_uuid: UUID of the user (actor) accessing the workgroup
        workgroup_uuid: UUID of the workgroup to list entries from
    
    Returns:
        Formatted list of all files and folders in the workgroup root
    """
    logger.info(f"Tool called: list_workgroup_entries({actor_uuid}, {workgroup_uuid})")
    
    if not LINSHARE_BASE_URL:
        return "Error: LINSHARE_BASE_URL not configured."
    if not LINSHARE_USERNAME or not LINSHARE_PASSWORD:
        return "Error: LinShare credentials not configured."
    
    try:
        url = f"{LINSHARE_BASE_URL}/{actor_uuid}/workgroups/{workgroup_uuid}/entries"
        
        response = requests.get(
            url,
            auth=HTTPBasicAuth(LINSHARE_USERNAME, LINSHARE_PASSWORD),
            headers={'accept': 'application/json'},
            timeout=10
        )
        response.raise_for_status()
        
        entries = response.json()
        
        if not entries:
            return f"No entries found in workgroup {workgroup_uuid}."
        
        # Separate folders and files
        folders = [e for e in entries if e.get('type') == 'FOLDER']
        files = [e for e in entries if e.get('type') in ['DOCUMENT', 'DOCUMENT_REVISION']]
        
        # Format the response nicely
        result = f"Workgroup Entries for {workgroup_uuid}\n"
        result += f"({len(entries)} total: {len(folders)} folders, {len(files)} files)\n\n"
        
        # List folders first
        if folders:
            result += "ðŸ“ FOLDERS:\n"
            for i, folder in enumerate(folders, 1):
                result += f"{i}. {folder.get('name', 'Unnamed folder')}"
                result += f" | UUID: {folder.get('uuid', 'N/A')}"
                
                if folder.get('creationDate'):
                    try:
                        from datetime import datetime
                        dt = datetime.fromisoformat(folder['creationDate'].replace('Z', '+00:00'))
                        result += f" | Created: {dt.strftime('%Y-%m-%d %H:%M')}"
                    except:
                        pass
                
                if folder.get('modificationDate'):
                    try:
                        from datetime import datetime
                        dt = datetime.fromisoformat(folder['modificationDate'].replace('Z', '+00:00'))
                        result += f" | Modified: {dt.strftime('%Y-%m-%d %H:%M')}"
                    except:
                        pass
                
                result += "\n"
            result += "\n"
        
        # List files
        if files:
            result += "ðŸ“„ FILES:\n"
            for i, file in enumerate(files, 1):
                result += f"{i}. {file.get('name', 'Unnamed file')}"
                
                # File size
                size = file.get('size', 0)
                if size:
                    result += f" | Size: {format_file_size(size)}"
                
                # MIME type
                if file.get('mimeType'):
                    result += f" | Type: {file['mimeType']}"
                
                result += f"\n   UUID: {file.get('uuid', 'N/A')}"
                
                # Dates
                if file.get('creationDate'):
                    try:
                        from datetime import datetime
                        dt = datetime.fromisoformat(file['creationDate'].replace('Z', '+00:00'))
                        result += f" | Uploaded: {dt.strftime('%Y-%m-%d %H:%M')}"
                    except:
                        pass
                
                # Author
                if file.get('lastAuthor'):
                    author = file['lastAuthor']
                    author_name = f"{author.get('firstName', '')} {author.get('lastName', '')}".strip()
                    if author_name:
                        result += f"\n   Author: {author_name}"
                    if author.get('mail'):
                        result += f" ({author['mail']})"
                
                result += "\n\n"
        
        return result
        
    except requests.exceptions.HTTPError as e:
        logger.error(f"HTTP error listing workgroup entries: {e}")
        return f"Error retrieving workgroup entries: {e.response.status_code} - {e.response.text}"
    except Exception as e:
        logger.error(f"Error listing workgroup entries: {e}")
        return f"Error: {str(e)}"


def format_file_size(size_bytes: int) -> str:
    """Convert bytes to human-readable format."""
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if size_bytes < 1024.0:
            return f"{size_bytes:.1f} {unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.1f} PB"


@mcp.tool()
def create_shared_space(
    user_uuid: str,
    name: str,
    node_type: str,
    parent_uuid: str = None,
    description: str = None
) -> str:
    """Create a new workspace or workgroup in LinShare.
    
    Args:
        user_uuid: The user's UUID (actor creating the space)
        name: Name of the workspace/workgroup (required)
        node_type: Type of node - must be either "WORK_SPACE" or "WORK_GROUP" (required)
        parent_uuid: UUID of parent WORK_SPACE (only for WORK_GROUP, optional)
        description: Description of the workspace/workgroup (optional)
    
    Returns:
        JSON string with created shared space information
    """
    logger.info(f"Tool called: create_shared_space({user_uuid}, {name}, {node_type})")
    
    if not LINSHARE_BASE_URL:
        return "Error: LINSHARE_BASE_URL not configured."
    
    if not LINSHARE_USERNAME or not LINSHARE_PASSWORD:
        return "Error: LinShare credentials not configured."
    
    # Validate node_type
    valid_types = ["WORK_SPACE", "WORK_GROUP"]
    if node_type not in valid_types:
        return f"Error: node_type must be one of {valid_types}"
    
    try:
        url = f"{LINSHARE_BASE_URL}/{user_uuid}/shared_space_nodes"
        
        # Build request body
        payload = {
            "name": name,
            "nodeType": node_type
        }
        
        if parent_uuid:
            payload["parentUuid"] = parent_uuid
        
        if description:
            payload["description"] = description
        
        response = requests.post(
            url,
            json=payload,
            auth=HTTPBasicAuth(LINSHARE_USERNAME, LINSHARE_PASSWORD),
            headers={
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            timeout=10
        )
        response.raise_for_status()
        
        space_data = response.json()
        
        result = f"""Shared Space Created Successfully:
- Name: {space_data.get('name')}
- UUID: {space_data.get('uuid')}
- Type: {space_data.get('nodeType')}
- Creation Date: {space_data.get('creationDate')}
- Description: {space_data.get('description', 'N/A')}
"""
        if parent_uuid:
            result += f"- Parent UUID: {space_data.get('parentUuid')}\n"
        
        return result
        
    except requests.RequestException as e:
        logger.error(f"Error creating shared space: {str(e)}")
        if hasattr(e.response, 'text'):
            return f"Error creating shared space: {str(e)}\nResponse: {e.response.text}"
        return f"Error creating shared space: {str(e)}"


# ============================================================================
# SHARED SPACE (WORKSPACE/DRIVE) TOOLS
# ============================================================================

@mcp.tool()
def list_user_shared_spaces(actor_uuid: str) -> str:
    """List all shared spaces (Workspaces, Drives) that a user is a member of.
    
    Args:
        actor_uuid: UUID of the user
    
    Returns:
        List of workspaces and drives the user belongs to with roles
    """
    logger.info(f"Tool called: list_user_shared_spaces({actor_uuid})")
    
    if not LINSHARE_BASE_URL:
        return "Error: LINSHARE_BASE_URL not configured."
    if not LINSHARE_USERNAME or not LINSHARE_PASSWORD:
        return "Error: LinShare credentials not configured."
    
    try:
        url = f"{LINSHARE_BASE_URL}/{actor_uuid}/shared_space_members"
        
        response = requests.get(
            url,
            auth=HTTPBasicAuth(LINSHARE_USERNAME, LINSHARE_PASSWORD),
            headers={'accept': 'application/json'},
            timeout=30
        )
        response.raise_for_status()
        
        memberships = response.json()
        
        if not memberships:
            return "User is not a member of any shared spaces."
        
        # Separate by type (exclude workgroups)
        workspaces = [m for m in memberships if m.get('node', {}).get('nodeType') == 'WORK_SPACE']
        drives = [m for m in memberships if m.get('node', {}).get('nodeType') == 'DRIVE']
        
        result = f"Shared Spaces for User ({len(workspaces) + len(drives)} total):\n\n"
        
        if workspaces:
            result += f"ðŸ“ WORKSPACES ({len(workspaces)}):\n"
            for i, membership in enumerate(workspaces, 1):
                node = membership.get('node', {})
                role = membership.get('role', {})
                
                result += f"{i}. {node.get('name', 'Unnamed workspace')}\n"
                result += f"   UUID: {node.get('uuid', 'N/A')}\n"
                result += f"   Role: {role.get('name', 'N/A')}\n"
                result += f"   Membership UUID: {membership.get('uuid', 'N/A')}\n"
                
                if node.get('creationDate'):
                    try:
                        from datetime import datetime
                        dt = datetime.fromisoformat(node['creationDate'].replace('Z', '+00:00'))
                        result += f"   Created: {dt.strftime('%Y-%m-%d')}\n"
                    except:
                        pass
                
                result += "\n"
            result += "\n"
        
        if drives:
            result += f"ðŸ’¾ DRIVES ({len(drives)}):\n"
            for i, membership in enumerate(drives, 1):
                node = membership.get('node', {})
                role = membership.get('role', {})
                
                result += f"{i}. {node.get('name', 'Unnamed drive')}\n"
                result += f"   UUID: {node.get('uuid', 'N/A')}\n"
                result += f"   Role: {role.get('name', 'N/A')}\n"
                result += f"   Membership UUID: {membership.get('uuid', 'N/A')}\n"
                
                if node.get('parentUuid'):
                    result += f"   Parent: {node['parentUuid']}\n"
                
                result += "\n"
            result += "\n"
        
        return result
        
    except Exception as e:
        logger.error(f"Error: {e}")
        return f"Error: {str(e)}"


@mcp.tool()
def list_available_workspace_roles() -> str:
    """List available workspace roles with their UUIDs.
    
    Returns:
        List of workspace roles with UUIDs and descriptions
    """
    logger.info("Tool called: list_available_workspace_roles()")
    
    try:
        workspace_roles = COMMON_ROLES.get('WORK_SPACE', {})
        
        if not workspace_roles:
            return "Error: No workspace roles found in COMMON_ROLES."
        
        result = "Available Workspace Roles:\n\n"
        
        # Use .get() to safely access keys
        admin_uuid = workspace_roles.get('WORK_SPACE_ADMIN')
        writer_uuid = workspace_roles.get('WORK_SPACE_WRITER')
        reader_uuid = workspace_roles.get('WORK_SPACE_READER')
        
        if admin_uuid:
            result += "1. ðŸ‘‘ WORK_SPACE_ADMIN\n"
            result += f"   UUID: {admin_uuid}\n"
            result += "   Description: Full control - can manage members and settings\n\n"
        
        if writer_uuid:
            result += "2. âœï¸ WORK_SPACE_WRITER\n"
            result += f"   UUID: {writer_uuid}\n"
            result += "   Description: Can create, edit, and delete content\n\n"
        
        if reader_uuid:
            result += "3. ðŸ‘ï¸ WORK_SPACE_READER\n"
            result += f"   UUID: {reader_uuid}\n"
            result += "   Description: Read-only access\n\n"
        
        if not (admin_uuid or writer_uuid or reader_uuid):
            return "Error: No valid workspace roles found."
        
        return result
        
    except Exception as e:
        logger.error(f"Error: {e}")
        return f"Error: {str(e)}"


@mcp.tool()
def add_workspace_member(
    actor_uuid: str,
    workspace_uuid: str,
    account_uuid: str,
    role_name: str,
    mail: str
) -> str:
    """Add a member to a workspace with a specific role.
    
    Available roles (must use exact names):
    - WORK_SPACE_ADMIN: Full control
    - WORK_SPACE_WRITER: Can create and edit
    - WORK_SPACE_READER: Read-only
    
    Supports both INTERNAL and GUEST account types.
    
    Args:
        actor_uuid: UUID of the actor performing the action
        workspace_uuid: UUID of the workspace
        account_uuid: UUID of the user to add (can be INTERNAL or GUEST)
        role_name: Role name (WORK_SPACE_ADMIN, WORK_SPACE_WRITER, or WORK_SPACE_READER)
        mail: Email address of the user to add
    
    Returns:
        Confirmation with member details
    """
    logger.info(f"Tool called: add_workspace_member({account_uuid}, role: {role_name})")
    
    if not LINSHARE_BASE_URL:
        return "Error: LINSHARE_BASE_URL not configured."
    if not LINSHARE_USERNAME or not LINSHARE_PASSWORD:
        return "Error: LinShare credentials not configured."
    
    try:
        # Get role UUID
        role_uuid = get_role_uuid(role_name)
        
        if not role_uuid:
            return (f"âŒ Role '{role_name}' not found.\n\n"
                   f"Available roles (use exact names):\n"
                   f"- WORK_SPACE_ADMIN\n"
                   f"- WORK_SPACE_WRITER\n"
                   f"- WORK_SPACE_READER")
        
        # Get the full role name from COMMON_ROLES
        role_full_name = None
        workspace_roles = COMMON_ROLES.get('WORK_SPACE', {})
        for key, uuid in workspace_roles.items():
            if uuid == role_uuid:
                role_full_name = key
                break
        
        if not role_full_name:
            role_full_name = role_name.upper()
        
        # First, get workspace details
        workspace_url = f"{LINSHARE_BASE_URL}/{actor_uuid}/shared_spaces/{workspace_uuid}"
        workspace_response = requests.get(
            workspace_url,
            auth=HTTPBasicAuth(LINSHARE_USERNAME, LINSHARE_PASSWORD),
            headers={'accept': 'application/json'},
            timeout=30
        )
        
        if workspace_response.status_code != 200:
            return f"Error: Could not fetch workspace details: {workspace_response.status_code}\n{workspace_response.text}"
        
        workspace_data = workspace_response.json()
        
        # Get account details - try users endpoint first (for INTERNAL users)
        account_url = f"{LINSHARE_BASE_URL}/users/{mail}"
        account_response = requests.get(
            account_url,
            auth=HTTPBasicAuth(LINSHARE_USERNAME, LINSHARE_PASSWORD),
            headers={'accept': 'application/json'},
            timeout=30
        )
        
        # If user not found, try guests endpoint
        if account_response.status_code == 404:
            account_url = f"{LINSHARE_BASE_URL}/{actor_uuid}/guests/{account_uuid}"
            account_response = requests.get(
                account_url,
                auth=HTTPBasicAuth(LINSHARE_USERNAME, LINSHARE_PASSWORD),
                headers={'accept': 'application/json'},
                timeout=30
            )
        
        if account_response.status_code != 200:
            return f"Error: Could not fetch account details: {account_response.status_code}\n{account_response.text}"
        
        account_data = account_response.json()
        
        # Determine account type (INTERNAL or GUEST)
        account_type = account_data.get('accountType', 'INTERNAL')
        
        # Build complete payload matching the working example
        from datetime import datetime
        current_time = datetime.utcnow().isoformat() + "Z"
        
        payload = {
            "node": {
                "uuid": workspace_uuid,
                "name": workspace_data.get('name', ''),
                "parentUuid": workspace_data.get('parentUuid'),
                "nodeType": workspace_data.get('nodeType', 'WORK_SPACE'),
                "domainUuid": workspace_data.get('domainUuid', '')
            },
            "role": {
                "uuid": role_uuid,
                "name": role_full_name,
                "type": "WORK_SPACE"
            },
            "account": {
                "uuid": account_uuid,
                "name": f"{account_data.get('firstName', '')} {account_data.get('lastName', '')}".strip(),
                "firstName": account_data.get('firstName', ''),
                "lastName": account_data.get('lastName', ''),
                "mail": account_data.get('mail', ''),
                "accountType": account_type
            },
            "creationDate": current_time,
            "modificationDate": current_time,
            "nested": True,
            "type": "WORK_SPACE"
        }
        
        url = f"{LINSHARE_BASE_URL}/{actor_uuid}/shared_space_members"
        
        response = requests.post(
            url,
            auth=HTTPBasicAuth(LINSHARE_USERNAME, LINSHARE_PASSWORD),
            headers={
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            data=json.dumps(payload),
            timeout=30
        )
        
        if response.status_code not in [200, 201]:
            error_msg = f"Failed to add member: {response.status_code}\n"
            try:
                error_detail = response.json()
                error_msg += f"Error: {error_detail.get('message', response.text)}"
            except:
                error_msg += f"Response: {response.text}"
            return error_msg
        
        result = response.json()
        
        output = f"âœ… Member added to workspace!\n\n"
        
        if result.get('account'):
            account = result['account']
            output += f"Member: {account.get('firstName', '')} {account.get('lastName', '')}\n"
            output += f"Email: {account.get('mail', 'N/A')}\n"
            output += f"Account Type: {account.get('accountType', 'N/A')}\n"
        
        if result.get('role'):
            output += f"Role: {result['role'].get('name', 'N/A')}\n"
        
        if result.get('node'):
            output += f"Workspace: {result['node'].get('name', 'N/A')}\n"
        
        output += f"\nMembership UUID: {result.get('uuid', 'N/A')}"
        
        return output
        
    except Exception as e:
        logger.error(f"Error: {e}")
        return f"Error: {str(e)}"


@mcp.tool()
def remove_workspace_member(
    actor_uuid: str,
    membership_uuid: str
) -> str:
    """Remove a member from a workspace.
    
    IMPORTANT: Use the membership UUID, not the user UUID!
    Get membership UUIDs from list_user_shared_spaces().
    
    Args:
        actor_uuid: UUID of the actor performing the action
        membership_uuid: UUID of the membership to remove
    
    Returns:
        Confirmation of removal
    """
    logger.info(f"Tool called: remove_workspace_member({membership_uuid})")
    
    if not LINSHARE_BASE_URL:
        return "Error: LINSHARE_BASE_URL not configured."
    if not LINSHARE_USERNAME or not LINSHARE_PASSWORD:
        return "Error: LinShare credentials not configured."
    
    try:
        url = f"{LINSHARE_BASE_URL}/{actor_uuid}/shared_space_members/{membership_uuid}"
        
        response = requests.delete(
            url,
            auth=HTTPBasicAuth(LINSHARE_USERNAME, LINSHARE_PASSWORD),
            headers={
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            timeout=30
        )
        
        if response.status_code not in [200, 204]:
            return f"Failed to remove member: {response.status_code}\n{response.text}"
        
        # Try to parse response (may be empty for 204)
        try:
            result = response.json()
            
            output = f"âœ… Member removed from workspace!\n\n"
            
            if result.get('account'):
                account = result['account']
                output += f"Removed: {account.get('firstName', '')} {account.get('lastName', '')}\n"
                output += f"Email: {account.get('mail', 'N/A')}\n"
            
            if result.get('node'):
                output += f"From: {result['node'].get('name', 'N/A')}\n"
            
            return output
        except:
            return f"âœ… Member removed from workspace!\n\nMembership UUID: {membership_uuid}"
        
    except Exception as e:
        logger.error(f"Error: {e}")
        return f"Error: {str(e)}"



@mcp.tool()
def add_document_to_workgroup(
    user_uuid: str,
    workgroup_uuid: str,
    document_url: str,
    file_name: str,
    async_upload: bool = False,
    strict: bool = False
) -> str:
    """Add a document to a LinShare workgroup from a URL.
    
    Args:
        user_uuid: The user's UUID (actor uploading the document)
        workgroup_uuid: The workgroup UUID where the document will be added
        document_url: URL of the document to upload (must be publicly accessible)
        file_name: Name of the file (required)
        async_upload: Enable asynchronous upload processing (default: False)
        strict: If True, return error if file with same name exists. If False, auto-rename (default: False)
    
    Returns:
        JSON string with uploaded document information
    """
    logger.info(f"Tool called: add_document_to_workgroup({user_uuid}, {workgroup_uuid}, {file_name})")
    
    if not LINSHARE_BASE_URL:
        return "Error: LINSHARE_BASE_URL not configured."
    
    if not LINSHARE_USERNAME or not LINSHARE_PASSWORD:
        return "Error: LinShare credentials not configured."
    
    try:
        # NOTE: The endpoint is /entries/url for URL-based uploads
        url = f"{LINSHARE_BASE_URL}/{user_uuid}/workgroups/{workgroup_uuid}/entries/url"
        
        # Query parameters
        params = {
            'async': str(async_upload).lower(),
            'strict': str(strict).lower()
        }
        
        # Build request body
        payload = {
            "url": document_url,
            "fileName": file_name
        }
        
        response = requests.post(
            url,
            params=params,
            json=payload,
            auth=HTTPBasicAuth(LINSHARE_USERNAME, LINSHARE_PASSWORD),
            headers={
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            timeout=30
        )
        response.raise_for_status()
        
        doc_data = response.json()
        
        result = f"""Document Added Successfully:
- Name: {doc_data.get('name')}
- UUID: {doc_data.get('uuid')}
- Size: {doc_data.get('size')} bytes
- Type: {doc_data.get('type')}
- Creation Date: {doc_data.get('creationDate')}
- Modification Date: {doc_data.get('modificationDate')}
"""
        
        return result
        
    except requests.RequestException as e:
        logger.error(f"Error adding document to workgroup: {str(e)}")
        if hasattr(e, 'response') and e.response is not None:
            return f"Error adding document to workgroup: {str(e)}\nResponse: {e.response.text}"
        return f"Error adding document to workgroup: {str(e)}"


@mcp.tool()
def list_user_documents(user_uuid: str) -> str:
    """List all documents in a user's personal space.

    Args:
        user_uuid: The user's UUID (actor whose documents to list)

    Returns:
        Formatted list of all documents owned by the user
    """
    logger.info(f"Tool called: list_user_documents({user_uuid})")

    if not LINSHARE_BASE_URL:
        return "Error: LINSHARE_BASE_URL not configured."

    if not LINSHARE_USERNAME or not LINSHARE_PASSWORD:
        return "Error: LinShare credentials not configured."

    try:
        url = f"{LINSHARE_BASE_URL}/{user_uuid}/documents"

        response = requests.get(
            url,
            auth=HTTPBasicAuth(LINSHARE_USERNAME, LINSHARE_PASSWORD),
            headers={'accept': 'application/json'},
            timeout=10
        )
        response.raise_for_status()

        documents = response.json()

        if not documents:
            return "No documents found in user's personal space."

        # Format the response nicely
        result = f"Personal Documents ({len(documents)} total):\n\n"

        for i, doc in enumerate(documents, 1):
            result += f"{i}. {doc.get('name', 'Unnamed')}\n"
            result += f"   - UUID: {doc.get('uuid')}\n"
            result += f"   - Size: {doc.get('size', 0)} bytes\n"
            result += f"   - Type: {doc.get('type', 'N/A')}\n"
            result += f"   - Creation Date: {doc.get('creationDate', 'N/A')}\n"
            result += f"   - Modification Date: {doc.get('modificationDate', 'N/A')}\n"
            if doc.get('description'):
                result += f"   - Description: {doc.get('description')}\n"
            result += "\n"

        return result

    except requests.RequestException as e:
        logger.error(f"Error fetching user documents: {str(e)}")
        if hasattr(e, 'response') and e.response is not None:
            return f"Error fetching user documents: {str(e)}\nResponse: {e.response.text}"
        return f"Error fetching user documents: {str(e)}"

@mcp.tool()
def share_documents(
    user_uuid: str,
    document_uuids: list,
    recipient_emails: list = None,
    mailing_list_uuid: str = None,
    subject: str = None,
    message: str = None,
    expiration_date: str = None,
    secured: bool = False,
    creation_acknowledgement: bool = False
) -> str:
    """Share documents from user's personal space with other users.
    
    Args:
        user_uuid: The user's UUID (actor sharing the documents)
        document_uuids: List of document UUIDs to share (required)
        recipient_emails: List of recipient email addresses (at least one of recipient_emails or mailing_list_uuid required)
        mailing_list_uuid: UUID of mailing list to share with (alternative to recipient_emails)
        subject: Subject line for the share notification
        message: Custom message to include with the share
        expiration_date: Expiration date in ISO format (e.g., "2025-12-31T23:59:59Z")
        secured: Whether to require password protection (default: False)
        creation_acknowledgement: Send acknowledgement to sender (default: False)
    
    Returns:
        JSON string with share creation result
    """
    logger.info(f"Tool called: share_documents({user_uuid}, {len(document_uuids)} documents)")
    
    if not LINSHARE_BASE_URL:
        return "Error: LINSHARE_BASE_URL not configured."
    
    if not LINSHARE_USERNAME or not LINSHARE_PASSWORD:
        return "Error: LinShare credentials not configured."
    
    # Validate that at least one recipient method is provided
    if not recipient_emails and not mailing_list_uuid:
        return "Error: Either recipient_emails or mailing_list_uuid must be provided."
    
    try:
        url = f"{LINSHARE_BASE_URL}/{user_uuid}/shares"
        
        # Build request body
        payload = {
            "documents": document_uuids,
            "secured": secured,
            "creationAcknowledgement": creation_acknowledgement
        }
        
        # Add recipients if provided
        if recipient_emails:
            payload["recipients"] = [{"mail": email} for email in recipient_emails]
        
        # Add mailing list if provided
        if mailing_list_uuid:
            payload["mailingListUuid"] = mailing_list_uuid
        
        # Add optional fields
        if subject:
            payload["subject"] = subject
        
        if message:
            payload["message"] = message
        
        if expiration_date:
            payload["expirationDate"] = expiration_date
        
        response = requests.post(
            url,
            json=payload,
            auth=HTTPBasicAuth(LINSHARE_USERNAME, LINSHARE_PASSWORD),
            headers={
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            timeout=30
        )
        response.raise_for_status()
        
        share_data = response.json()
        
        # Format the response
        result = f"""Documents Shared Successfully:\n"""
        
        # Handle both single share and multiple shares response
        shares = share_data if isinstance(share_data, list) else [share_data]
        
        for i, share in enumerate(shares, 1):
            result += f"\nShare {i}:\n"
            result += f"   - Share UUID: {share.get('uuid')}\n"
            result += f"   - Document: {share.get('name', 'N/A')}\n"
            result += f"   - Recipient: {share.get('recipient', {}).get('mail', 'N/A')}\n"
            result += f"   - Size: {share.get('size', 0)} bytes\n"
            result += f"   - Creation Date: {share.get('creationDate', 'N/A')}\n"
            if share.get('expirationDate'):
                result += f"   - Expiration Date: {share.get('expirationDate')}\n"
            result += f"   - Downloaded: {share.get('downloaded', 0)} times\n"
        
        return result
        
    except requests.RequestException as e:
        logger.error(f"Error sharing documents: {str(e)}")
        if hasattr(e, 'response') and e.response is not None:
            return f"Error sharing documents: {str(e)}\nResponse: {e.response.text}"
        return f"Error sharing documents: {str(e)}"


@mcp.tool()
def upload_document_to_personal_space(
    user_uuid: str,
    document_url: str,
    file_name: str,
    file_size: int = None,
    async_upload: bool = False
) -> str:
    """Upload a document to a user's personal space in LinShare from a URL.
    
    Args:
        user_uuid: The user's UUID (actor who will own the document)
        document_url: URL of the document to upload (must be publicly accessible)
        file_name: Name of the file (required)
        file_size: Size of the file in bytes (optional)
        async_upload: Enable asynchronous upload processing (default: False)
    
    Returns:
        JSON string with uploaded document information
    """
    logger.info(f"Tool called: upload_document_to_personal_space({user_uuid}, {file_name})")
    
    if not LINSHARE_BASE_URL:
        return "Error: LINSHARE_BASE_URL not configured."
    
    if not LINSHARE_USERNAME or not LINSHARE_PASSWORD:
        return "Error: LinShare credentials not configured."
    
    try:
        url = f"{LINSHARE_BASE_URL}/{user_uuid}/documents"
        
        # Query parameters
        params = {
            'async': str(async_upload).lower()
        }
        
        # Build request body
        payload = {
            "url": document_url,
            "fileName": file_name
        }
        
        # Add file size only if provided
        if file_size is not None:
            payload["size"] = file_size
        
        logger.info(f"Uploading {file_name} to personal space")
        
        response = requests.post(
            url,
            params=params,
            json=payload,
            auth=HTTPBasicAuth(LINSHARE_USERNAME, LINSHARE_PASSWORD),
            headers={
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            timeout=60
        )
        
        logger.info(f"Response status: {response.status_code}")
        
        response.raise_for_status()
        
        doc_data = response.json()
        
        result = f"""Document Uploaded to Personal Space Successfully:
- Name: {doc_data.get('name')}
- UUID: {doc_data.get('uuid')}
- Size: {doc_data.get('size')} bytes
- Type: {doc_data.get('type')}
- SHA256: {doc_data.get('sha256sum', 'N/A')}
- Creation Date: {doc_data.get('creationDate')}
- Modification Date: {doc_data.get('modificationDate')}
"""
        
        return result
        
    except requests.RequestException as e:
        logger.error(f"Error uploading document to personal space: {str(e)}")
        error_msg = f"Error uploading document to personal space: {str(e)}"
        if hasattr(e, 'response') and e.response is not None:
            error_msg += f"\nStatus Code: {e.response.status_code}"
            error_msg += f"\nResponse: {e.response.text}"
        return error_msg
    except Exception as e:
        logger.error(f"Unexpected error: {str(e)}")
        return f"Unexpected error: {str(e)}"

@mcp.tool()
def search_user_audit_logs(
    actor_uuid: str,
    action: str | None = None,
    entry_type: str | None = None,
    force_all: bool = False,
    begin_date: str | None = None,
    end_date: str | None = None,
    max_results: int = 50
) -> str:
    """Search and filter audit logs for a specific LinShare user.
    
    Args:
        actor_uuid: UUID of the user whose audit logs to retrieve
        action: Filter by action type (CREATE, UPDATE, DELETE, GET, DOWNLOAD, SUCCESS, FAILURE, PURGE)
        entry_type: Filter by entry type (SHARE_ENTRY, DOCUMENT_ENTRY, GUEST, WORK_SPACE, etc.)
        force_all: If true, returns all audit entries for the user (default: false)
        begin_date: Start date for filtering logs (ISO 8601: YYYY-MM-DD or YYYY-MM-DDTHH:MM:SS)
        end_date: End date for filtering logs (ISO 8601: YYYY-MM-DD or YYYY-MM-DDTHH:MM:SS)
        max_results: Maximum number of results to return for readability (default: 50)
    
    Returns:
        Formatted list of audit log entries
    """
    logger.info(f"Tool called: search_user_audit_logs({actor_uuid}, action={action}, type={entry_type})")
    
    if not LINSHARE_BASE_URL:
        return "Error: LINSHARE_BASE_URL not configured."
    if not LINSHARE_USERNAME or not LINSHARE_PASSWORD:
        return "Error: LinShare credentials not configured."
    
    try:
        # Build query parameters
        params = {}
        if action:
            params["action"] = action
        if entry_type:
            params["type"] = entry_type
        if force_all:
            params["forceAll"] = "true"
        if begin_date:
            params["beginDate"] = begin_date
        if end_date:
            params["endDate"] = end_date
        
        url = f"{LINSHARE_BASE_URL}/audit/{actor_uuid}"
        
        response = requests.get(
            url,
            params=params,
            auth=HTTPBasicAuth(LINSHARE_USERNAME, LINSHARE_PASSWORD),
            headers={'accept': 'application/json'},
            timeout=10
        )
        response.raise_for_status()
        
        logs = response.json()
        
        if not logs:
            return "No audit logs found matching the specified criteria."
        
        # Limit results for readability
        total_count = len(logs)
        display_logs = logs[:max_results]
        
        # Format the response nicely
        result = f"Audit Logs for User {actor_uuid}"
        if action:
            result += f" | Action: {action}"
        if entry_type:
            result += f" | Type: {entry_type}"
        if begin_date or end_date:
            result += f" | Date Range: {begin_date or 'start'} to {end_date or 'end'}"
        
        result += f"\n({total_count} total"
        if total_count > max_results:
            result += f", showing first {max_results}"
        result += ")\n\n"
        
        for i, log in enumerate(display_logs, 1):
            result += f"{i}. "
            result += f"[{log.get('action', 'N/A')}] "
            result += f"{log.get('type', 'N/A')}"
            
            # Date
            creation_date = log.get('creationDate', 'N/A')
            if creation_date != 'N/A':
                try:
                    from datetime import datetime
                    dt = datetime.fromisoformat(creation_date.replace('Z', '+00:00'))
                    creation_date = dt.strftime("%Y-%m-%d %H:%M:%S")
                except:
                    pass
            result += f" | {creation_date}"
            
            # Actor
            if 'actor' in log:
                actor = log['actor']
                actor_name = f"{actor.get('firstName', '')} {actor.get('lastName', '')}".strip()
                if actor_name:
                    result += f" | Actor: {actor_name}"
                if actor.get('mail'):
                    result += f" ({actor['mail']})"
            
            # Resource
            if 'resource' in log:
                resource = log['resource']
                if resource.get('name'):
                    result += f"\n   Resource: {resource['name']}"
                if resource.get('uuid'):
                    result += f" (UUID: {resource['uuid']})"
            
            # Auth user if different from actor
            if 'authUser' in log and log['authUser'] != log.get('actor'):
                auth_user = log['authUser']
                auth_name = f"{auth_user.get('firstName', '')} {auth_user.get('lastName', '')}".strip()
                if auth_name:
                    result += f"\n   Auth User: {auth_name}"
            
            result += "\n\n"
        
        if total_count > max_results:
            result += f"\n... and {total_count - max_results} more entries (use max_results parameter to see more)"
        
        return result
        
    except requests.exceptions.HTTPError as e:
        logger.error(f"HTTP error searching audit logs: {e}")
        return f"Error retrieving audit logs: {e.response.status_code} - {e.response.text}"
    except Exception as e:
        logger.error(f"Error searching audit logs: {e}")
        return f"Error: {str(e)}"

# Run server in stdio mode
if __name__ == "__main__":
    logger.info(f"Starting {name} in stdio mode")
    mcp.run(transport="stdio")
